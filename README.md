# 设计模式（Java语言描述）
---

## 一、7大设计原则

1. 单一职责
    - 一个类/方法应该只负责一个任务，如果A负责2个职责，职责1和职责2，职责1的需求变更改变A而影响到职责2，应该将A分离为A1，A2。
2. 接口隔离
    - 一个类不应该依赖它不需要的接口。
    - 一个类对另一个类的依赖应该建立在最小依赖的基础上。
3. 依赖倒置
    - 高层模块依赖底层模块不应该在高层模块中直接创建低层模块，而是通过外部传入依赖模块。
    - 高层模块不应该直接依赖低层模块，而是依赖低层模块的抽象。
4. 里氏替换
    - 一个程序中子类对象都替换成父类对象，程序运行的结果不变。
    - 遵循里氏替换原则，子类尽量不要重写父类方法。
    - 违背里氏替换原则的解决方法，父类和子类解除继承关系，抽象出一个更一般的基类，都继承基类，通过组合、依赖来解决问题。
5. 开闭原则
    - 一个软件类/方法/模块，应该对扩展开放（提供方），对修改关闭（使用方）。
    - 抽象构建框架，扩展实现细节。
6. 迪米特法则
    - 一个对象应该对其他对象保持最少的了解。（只使用public方法，不必了解具体实现）
    - 只与直接的朋友对话。直接朋友：成员属性，方法参数，方法返回值。不要和陌生的变量对话。
7. 合成复用原则
    - 耦合尽量使用合成/聚合的方式，不要继承
    
## 二、UML类图
类之间的关系
1. 依赖，dependency，只要类中用到了就可以说是依赖，包括成员属性，方法参数、返回值
2. 泛化， generalization，即继承
3. 实现， realization，即实现接口
4. 关联，association，
5. 聚合，aggregation，整体与部分的关系，但是部分可以分开，比如人和身份证
6. 组合，composition，整体与部分的关系，但是部分不可以分开，比如人和脑袋
    
## 三、单例模式
1. 饿汉静态常量，线程安全
2. 饿汉静态代码块，线程安全
3. 懒汉，线程不安全
4. 懒汉同步代码块，线程安全
5. 双重检查，线程安全（推荐）
6. 静态内部类，线程安全（推荐）
7. 枚举，线程安全（推荐）

## 四、工厂方法

1. 简单工厂
    1. 创建对象的任务交给一个工厂类完成，根据传入的信息创建具体的对象
2. 工厂方法
    1. 当要创建的对象有多个品类时，定义一个工厂基类，工厂的不同子类负责创建不同品类的对象
3. 抽象工厂
    1. 定义一个抽象工厂接口，声明创建方法
    2. 定义一个基本产品接口，所有种类的产品实现基本产品
    3. 多个工厂类实现抽象工厂接口，复制创建具体某个种类的产品
    
## 五、原型模式

> 当前对象作为原型，通过克隆生成新的对象，简化创建对象。

1. 浅拷贝
    - 定义：基本类型成员复制值，引用类型成员传递引用
    - 实现：实现Cloneable接口，重写clone()方法
2. 深拷贝
    - 定义：基本类型成员复制值，引用类型成员生成新的内容相同对象并复制。
    - 实现：
        1. 实现Cloneable接口，重写clone()方法，值复制调用super.clone，引用复制调用引用类型成员的clone方法
        2. 实现Serializable接口，通过序列化实现。object-》ObjectOutputStream-》ByteArrayOutputStream-》byte[]-》ByteInputStream-》ObjectInputStream-》CloneObject。（推荐使用）
        
## 六、建造者模式
 
> 解决复杂对象的构建问题，按照构建蓝图一步步创建对象，使用者无需了解对象创建的细节。

### 四个角色：
- product：产品，即要创建的对象
- builder：抽象创建者，定义了创建对象的步骤
- concrete builder：具体创建者，实现了创建对象的步骤落实，以及返回对象
- director：指挥者，指挥具体创建者通过各个步骤创建对象
 
### UML类图：

![](https://uploader.shimo.im/f/jdg4CYbwQag3Oxwg.jpg)
     
### 和工厂模式对比：
- 工厂模式创建的是一系列产品，通过不同的工厂创建对应的对象，不需要关心构建过程
- 建造者模式是解决对象创建时的复杂问题，类似通过设计图一步步组装产品的过程

## 七、适配器模式

> 源接口和目标接口不兼容时，使用一个适配器兼容二者，使得源和目标可以协同工作。

### 类适配器
1. 源（被适配者，为具体的类）
2. 目标（客户所需的接口，为接口或者抽象类）
3. 适配器（继承源类，实现目标接口，使得二者兼容）
4. 客户端（使用目标接口，传入适配器对象）

### 对象适配器：
1. 适配器依赖源，不使用继承，而是聚合一个源的对象，降低耦合

### 接口适配器：
1. 定义一个适配器，对接口所有的方式空实现
2. 接口的子类只想使用接口的某些方法时，子类继承适配器，重写自己想用的方法

### UML类图

![](https://uploader.shimo.im/f/r7Wkn6Arek4bg2xl.jpg)

## 八、桥接模式
将抽象部分与它的实现部分分离，使它们都可以独立地变化。适用于对象有多个维度变化时使用。

角色：
1. 实现者：实现类的接口
2. 具体实现者：实现具体的功能
3. 抽象者：聚合实现者，动态确定实现者的特性
4. 扩展抽象者：继承抽象者，可以加入新特性

UML类图：
![](https://uploader.shimo.im/f/fUNI7l8gK5UusJdV.jpg)

特点：
1. 将抽象和实现分开，解决了多继承而违背的单一职责原则的问题，在这2个维度上可以任意扩充
2. 增加了系统设计的复杂度，系统建立在抽象和实现的准确划分上，局限于2个维度的变化
3. 抽象和实现的通过聚合关联

常见场景：
1. 不同数据库厂商实现了各自的JDBC驱动
2. 不同平台的多格式视频处理
3. 银行转账：ATM、柜台、手机转账，用户有普通、银卡、金卡等

## 九、装饰者模式

> 动态的将新特性附加到对象上，采用聚合的方式，比继承更有弹性。类似给物品添加包装。

角色：
1. competent：组件抽象类
2. concrete competent：具体组件，组件很多可以抽象出缓存层
3. decorator：装饰者抽象类，继承competent，并且聚合competent
4. concrete decorator：具体装饰者

UML类图：
![](https://uploader.shimo.im/f/OVBuKxgNNy09S3mv.jpg)

应用：
JDK IO体系中输入输出流的设计。